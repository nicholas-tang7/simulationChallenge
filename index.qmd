---
title: "Simulation Challenge"
subtitle: "Generative Models and Monte Carlo Simulation"
format:
  html: default
  pdf: default
execute:
  echo: true
  eval: true
---

# üé≤ Simulation Challenge - Monte Carlo Analysis

## Challenge Overview

**Your Mission:** Create a comprehensive Quarto document that simulates one or two investment strategies, analyzes the results, and demonstrates your ability to present counter-intuitive findings compellingly. Then render the document to HTML and deploy it via GitHub Pages from a new repository called "simulationChallenge."

::: {.callout-warning}
## ‚ö†Ô∏è AI Partnership Required

This challenge pushes boundaries intentionally. You'll tackle problems that normally require weeks of study, but with Cursor AI as your partner (and your brain keeping it honest), you can accomplish more than you thought possible.

**The new reality:** The four stages of competence are Ignorance ‚Üí Awareness ‚Üí Learning ‚Üí Mastery. AI lets us produce Mastery-level work while operating primarily in the Awareness stage. I focus on awareness training, you leverage AI for execution, and together we create outputs that used to require years of dedicated study.
:::

## The Investment Game üéØ

### Original Game Strategy

::: {#exm-ErgodicityEconomicsExample}
Imagine you are offered the following game and given a $1,000 budget in a special account to play the game: I will flip a coin, and if it comes up heads, we increase your account's balance by 50%; if it comes up tails, we reduce your account's balance by 40%. We are not only doing this once, but we will do it once per year until you turn 55. When you turn 55, you will receive the balance in your account.
:::

### Generative DAG Model for the Investment Game




## Challenge Requirements üìã

### Minimum Requirements for Any Points on Challenge

1. **Create a Quarto Document:** Write a concise quarto markdown file that includes a narrative of what you are doing along with the requested code, results, and visualizations of your simulations.

   ::: {.callout-tip}
   ## üí° Pro Tip: Source File Reference
   
   **Need help with Quarto syntax or DAFT diagrams?** You can find the complete source `.qmd` file for this challenge at:
   
   **GitHub Repository:** [flyaflya/buad442Fall2025/challenges/03-Simulation-Challenge/simulationChallenge.qmd](https://github.com/flyaflya/buad442Fall2025/blob/main/challenges/03-Simulation-Challenge/simulationChallenge.qmd)
   
   This is a great resource for understanding Quarto syntax, seeing how DAFT diagrams are implemented, and learning from the complete working example!
   :::

2. **Render to HTML:** You must render the quarto markdown file to HTML.

3. **GitHub Repository:** The rendered HTML must be uploaded to a new GitHub repository called "simulationChallenge" in your Github account.

4. **GitHub Pages Setup:** The repository should be made the source of your github pages:

   - Go to your repository settings (click the "Settings" tab in your GitHub repository)
   - Scroll down to the "Pages" section in the left sidebar
   - Under "Source", select "Deploy from a branch"
   - Choose "main" branch and "/ (root)" folder
   - Click "Save"
   - Your site will be available at: `https://[your-username].github.io/simulationChallenge/`
   - **Note:** It may take a few minutes for the site to become available after enabling Pages

## Grading Rubric üéì

### Questions to Answer for 75% Grade on Challenge

1. **Expected Value Analysis:** What is the "expected value" of your account balance after 1 coin flip for the original game?

### Solution: Expected Value Calculation

**Mathematical Approach:**

For the original game:
- **Initial balance**: $1,000
- **Heads (50% probability)**: Balance becomes $1,000 √ó 1.5 = $1,500
- **Tails (50% probability)**: Balance becomes $1,000 √ó 0.6 = $600

**Expected Value Formula:**
$$E[Balance] = P(Heads) \times Balance_{Heads} + P(Tails) \times Balance_{Tails}$$

$$E[Balance] = 0.5 \times \$1,500 + 0.5 \times \$600 = \$750 + \$300 = \$1,050$$

**Answer: The expected value of the account balance after 1 coin flip is $1,050.**

**Code Implementation:**

::: {.panel-tabset}

### R

```{r}
#| label: expected-value-r
#| fig-cap: R calculation of expected value after 1 coin flip
#| echo: true

# Game parameters
initial_balance <- 1000
heads_multiplier <- 1.5  # +50% gain
tails_multiplier <- 0.6  # -40% loss
prob_heads <- 0.5
prob_tails <- 0.5

# Calculate possible outcomes
balance_heads <- initial_balance * heads_multiplier
balance_tails <- initial_balance * tails_multiplier

# Calculate expected value
expected_value <- prob_heads * balance_heads + prob_tails * balance_tails

# Display results
cat("Initial Balance: $", initial_balance, "\n")
cat("Balance if Heads (+50%): $", balance_heads, "\n")
cat("Balance if Tails (-40%): $", balance_tails, "\n")
cat("Probability of Heads: ", prob_heads, "\n")
cat("Probability of Tails: ", prob_tails, "\n")
cat("Expected Value: $", expected_value, "\n")
cat("Expected Gain/Loss: $", expected_value - initial_balance, "\n")
```

### Python

```{python}
#| label: expected-value-python
#| fig-cap: Python calculation of expected value after 1 coin flip
#| echo: true

import numpy as np

# Game parameters
initial_balance = 1000
heads_multiplier = 1.5  # +50% gain
tails_multiplier = 0.6  # -40% loss
prob_heads = 0.5
prob_tails = 0.5

# Calculate possible outcomes
balance_heads = initial_balance * heads_multiplier
balance_tails = initial_balance * tails_multiplier

# Calculate expected value
expected_value = prob_heads * balance_heads + prob_tails * balance_tails

# Display results
print(f"Initial Balance: ${initial_balance:,}")
print(f"Balance if Heads (+50%): ${balance_heads:,}")
print(f"Balance if Tails (-40%): ${balance_tails:,}")
print(f"Probability of Heads: {prob_heads}")
print(f"Probability of Tails: {prob_tails}")
print(f"Expected Value: ${expected_value:,}")
print(f"Expected Gain/Loss: ${expected_value - initial_balance:,}")
```

:::

2. **Expectation vs. Reality:** Is the expected value positive or negative? Do you expect your account to be worth more or less than $1,000 based on this result?

### Solution: Expectation vs. Reality Analysis

**Answer:** The expected value is **positive**! 

- **Expected Value**: $1,050
- **Initial Investment**: $1,000
- **Expected Gain**: $1,050 - $1,000 = **$50**

**Interpretation:**
Based on the expected value calculation, you should expect your account to be worth **more** than $1,000 after one coin flip. The expected value of $1,050 represents a 5% expected return on your initial investment.

**Key Insight:**
This is a **favorable game** from an expected value perspective. Even though you have a 50% chance of losing 40% of your money, the 50% gain when you win (50% increase) more than compensates for the loss, resulting in a positive expected return.

**Mathematical Verification:**
- Expected return = (0.5 √ó 0.5) + (0.5 √ó (-0.4)) = 0.25 - 0.20 = 0.05 = **5%**
- This confirms our expected value calculation: $1,000 √ó 1.05 = $1,050

3. **Single Simulation:** Run one simulation showing the dynamics of your account balance over time. Make an object-oriented matplotlib OR ggplot2 plot showing your simulated account balance over time (i.e. as you age). Comment on the results, are you happy?

### Solution: Single Simulation of Account Balance Over Time

**Game Parameters:**
- **Initial Age**: 18 years old
- **Final Age**: 55 years old  
- **Investment Period**: 37 years (55 - 18 = 37)
- **Initial Balance**: $1,000
- **Annual Coin Flip**: Heads (+50%) or Tails (-40%)

**Simulation Implementation:**

::: {.panel-tabset}

### R

```{r}
#| label: single-simulation-r
#| fig-cap: R single simulation of investment game over 37 years
#| echo: true

suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(ggplot2))

# Set seed for reproducibility
set.seed(123)

# Game parameters
initial_balance <- 1000
initial_age <- 18
final_age <- 55
n_years <- final_age - initial_age
heads_multiplier <- 1.5  # +50% gain
tails_multiplier <- 0.6  # -40% loss

# Simulate one complete path
simulate_investment_path <- function(initial_balance, n_years) {
  balance <- initial_balance
  path <- numeric(n_years + 1)
  path[1] <- initial_balance
  
  for (year in 1:n_years) {
    coin_flip <- rbinom(1, 1, 0.5)  # 1 = heads, 0 = tails
    if (coin_flip == 1) {
      balance <- balance * heads_multiplier  # +50% gain
    } else {
      balance <- balance * tails_multiplier  # -40% loss
    }
    path[year + 1] <- balance
  }
  
  return(path)
}

# Run single simulation
simulation_path <- simulate_investment_path(initial_balance, n_years)

# Create data frame for plotting
simulation_data <- tibble(
  age = initial_age:final_age,
  balance = simulation_path,
  year = 0:n_years
)

# Create the plot
p <- ggplot(simulation_data, aes(x = age, y = balance)) +
  geom_line(color = "steelblue", linewidth = 1.2) +
  geom_point(color = "darkblue", size = 2) +
  geom_hline(yintercept = initial_balance, color = "red", linetype = "dashed", linewidth = 1) +
  labs(
    title = "Investment Game: Single Simulation Path",
    subtitle = paste("37 Years of Annual Coin Flips (Age 18 to 55)"),
    x = "Age",
    y = "Account Balance ($)",
    caption = "Red dashed line shows initial investment ($1,000)\nHeads: +50% gain, Tails: -40% loss"
  ) +
  scale_y_continuous(
    labels = scales::dollar_format(),
    breaks = seq(0, max(simulation_data$balance) * 1.2, by = 5000)
  ) +
  scale_x_continuous(breaks = seq(18, 55, by = 5)) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12, color = "gray50"),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    panel.grid.minor = element_blank()
  )

# Display the plot
print(p)

# Summary statistics
final_balance <- simulation_data$balance[nrow(simulation_data)]
total_return <- (final_balance - initial_balance) / initial_balance * 100
max_balance <- max(simulation_data$balance)
min_balance <- min(simulation_data$balance)

cat("\n=== SIMULATION SUMMARY ===\n")
cat("Initial Balance (Age 18): $", format(initial_balance, big.mark = ","), "\n")
cat("Final Balance (Age 55): $", format(final_balance, big.mark = ","), "\n")
cat("Total Return: ", round(total_return, 1), "%\n")
cat("Maximum Balance: $", format(max_balance, big.mark = ","), "\n")
cat("Minimum Balance: $", format(min_balance, big.mark = ","), "\n")
cat("Years with gains: ", sum(diff(simulation_data$balance) > 0), "\n")
cat("Years with losses: ", sum(diff(simulation_data$balance) < 0), "\n")
```

### Python

```{python}
#| label: single-simulation-python
#| fig-cap: Python single simulation of investment game over 37 years
#| echo: true

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(123)

# Game parameters
initial_balance = 1000
initial_age = 18
final_age = 55
n_years = final_age - initial_age
heads_multiplier = 1.5  # +50% gain
tails_multiplier = 0.6  # -40% loss

# Simulate one complete path
def simulate_investment_path(initial_balance, n_years):
    balance = initial_balance
    path = [initial_balance]
    
    for year in range(n_years):
        coin_flip = np.random.binomial(1, 0.5)  # 1 = heads, 0 = tails
        if coin_flip == 1:
            balance = balance * heads_multiplier  # +50% gain
        else:
            balance = balance * tails_multiplier  # -40% loss
        path.append(balance)
    
    return path

# Run single simulation
simulation_path = simulate_investment_path(initial_balance, n_years)

# Create data frame for plotting
simulation_data = pd.DataFrame({
    'age': range(initial_age, final_age + 1),
    'balance': simulation_path,
    'year': range(n_years + 1)
})

# Create the plot
fig, ax = plt.subplots(figsize=(12, 8))
ax.plot(simulation_data['age'], simulation_data['balance'], 
        color='steelblue', linewidth=2, marker='o', markersize=4)
ax.axhline(y=initial_balance, color='red', linestyle='--', linewidth=2, 
           label='Initial Investment ($1,000)')
ax.set_title('Investment Game: Single Simulation Path\n37 Years of Annual Coin Flips (Age 18 to 55)', 
             fontsize=14, fontweight='bold')
ax.set_xlabel('Age', fontsize=12)
ax.set_ylabel('Account Balance ($)', fontsize=12)
ax.grid(True, alpha=0.3)
ax.legend()

# Format y-axis as currency
ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))
ax.set_xticks(range(18, 56, 5))

# Set y-axis limits with some padding
max_balance = max(simulation_data['balance'])
ax.set_ylim(0, max_balance * 1.1)

plt.tight_layout()
plt.show()

# Summary statistics
final_balance = simulation_data['balance'].iloc[-1]
total_return = (final_balance - initial_balance) / initial_balance * 100
max_balance = simulation_data['balance'].max()
min_balance = simulation_data['balance'].min()
gains = (simulation_data['balance'].diff() > 0).sum()
losses = (simulation_data['balance'].diff() < 0).sum()

print("\n=== SIMULATION SUMMARY ===")
print(f"Initial Balance (Age 18): ${initial_balance:,}")
print(f"Final Balance (Age 55): ${final_balance:,.2f}")
print(f"Total Return: {total_return:.1f}%")
print(f"Maximum Balance: ${max_balance:,.2f}")
print(f"Minimum Balance: ${min_balance:,.2f}")
print(f"Years with gains: {gains}")
print(f"Years with losses: {losses}")
```

:::

### Analysis and Interpretation

**Key Observations:**

1. **Volatility**: The account balance shows significant volatility over time, with large swings up and down based on the coin flip outcomes.

2. **Compound Effects**: The multiplicative nature of the gains and losses creates dramatic differences in outcomes. A few consecutive heads can lead to substantial growth, while consecutive tails can severely deplete the account.

3. **Path Dependency**: The final outcome depends heavily on the sequence of coin flips, not just the total number of heads vs. tails.

4. **Risk vs. Expected Value**: While the expected value suggests a positive return, the actual path shows the reality of high volatility and the possibility of significant losses.

**Are you happy with this result?**
This single simulation demonstrates the **high-risk, high-volatility nature** of this investment strategy. While the expected value is positive, the actual outcome depends entirely on luck and can vary dramatically from the expected value. This highlights the difference between theoretical expected value and real-world outcomes in volatile investments.

### Questions to Answer for 85% Grade on Challenge

4. **Multiple Simulations:** Run 100 simulations modelling the dynamics of your account balance over time. Make an object-oriented matplotlib OR ggplot2 plot showing a probability distribution of the 100 simulated account balances at age 55. Comment on the results, are you happy? Why or why not?

### Solution: 100 Simulations - Distribution of Final Balances

**Objective:** Run 100 independent simulations to understand the distribution of possible outcomes at age 55.

**Implementation:**

::: {.panel-tabset}

### R

```{r}
#| label: multiple-simulations-r
#| fig-cap: R distribution of final balances from 100 simulations
#| echo: true

suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(ggplot2))

# Set seed for reproducibility
set.seed(456)

# Game parameters
initial_balance <- 1000
initial_age <- 18
final_age <- 55
n_years <- final_age - initial_age
n_simulations <- 100
heads_multiplier <- 1.5  # +50% gain
tails_multiplier <- 0.6  # -40% loss

# Function to simulate one complete path and return final balance
simulate_final_balance <- function(initial_balance, n_years) {
  balance <- initial_balance
  
  for (year in 1:n_years) {
    coin_flip <- rbinom(1, 1, 0.5)  # 1 = heads, 0 = tails
    if (coin_flip == 1) {
      balance <- balance * heads_multiplier  # +50% gain
    } else {
      balance <- balance * tails_multiplier  # -40% loss
    }
  }
  
  return(balance)
}

# Run 100 simulations
final_balances <- replicate(n_simulations, simulate_final_balance(initial_balance, n_years))

# Create data frame for analysis
simulation_results <- tibble(
  simulation = 1:n_simulations,
  final_balance = final_balances
)

# Create histogram with density overlay
p <- ggplot(simulation_results, aes(x = final_balance)) +
  geom_histogram(aes(y = after_stat(density)), bins = 20, 
                 fill = "lightblue", alpha = 0.7, color = "black") +
  geom_density(color = "darkblue", linewidth = 1.2) +
  geom_vline(xintercept = initial_balance, color = "red", linetype = "dashed", linewidth = 1.5,
             label = "Initial Investment") +
  geom_vline(xintercept = mean(final_balances), color = "green", linetype = "solid", linewidth = 1.5,
             label = "Mean Final Balance") +
  labs(
    title = "Distribution of Final Account Balances at Age 55",
    subtitle = paste("100 Simulations of 37-Year Investment Game"),
    x = "Final Account Balance ($)",
    y = "Density",
    caption = "Red dashed line: Initial investment ($1,000)\nGreen solid line: Mean final balance"
  ) +
  scale_x_continuous(
    labels = scales::dollar_format(),
    trans = "log10",
    breaks = c(10, 100, 1000, 10000, 100000)
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12, color = "gray50"),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    panel.grid.minor = element_blank()
  )

# Display the plot
print(p)

# Summary statistics
mean_balance <- mean(final_balances)
median_balance <- median(final_balances)
sd_balance <- sd(final_balances)
min_balance <- min(final_balances)
max_balance <- max(final_balances)
prob_above_initial <- mean(final_balances > initial_balance)
prob_above_10000 <- mean(final_balances > 10000)

cat("\n=== 100 SIMULATIONS SUMMARY ===\n")
cat("Initial Investment: $", format(initial_balance, big.mark = ","), "\n")
cat("Mean Final Balance: $", format(mean_balance, big.mark = ",", digits = 2), "\n")
cat("Median Final Balance: $", format(median_balance, big.mark = ",", digits = 2), "\n")
cat("Standard Deviation: $", format(sd_balance, big.mark = ",", digits = 2), "\n")
cat("Minimum Final Balance: $", format(min_balance, big.mark = ",", digits = 2), "\n")
cat("Maximum Final Balance: $", format(max_balance, big.mark = ",", digits = 2), "\n")
cat("Probability > $1,000: ", round(prob_above_initial * 100, 1), "%\n")
cat("Probability > $10,000: ", round(prob_above_10000 * 100, 1), "%\n")
cat("Expected Value (1 year): $", format(initial_balance * 1.05, big.mark = ","), "\n")
cat("Expected Value (37 years): $", format(initial_balance * (1.05^37), big.mark = ",", digits = 2), "\n")
```

### Python

```{python}
#| label: multiple-simulations-python
#| fig-cap: Python distribution of final balances from 100 simulations
#| echo: true

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(456)

# Game parameters
initial_balance = 1000
initial_age = 18
final_age = 55
n_years = final_age - initial_age
n_simulations = 100
heads_multiplier = 1.5  # +50% gain
tails_multiplier = 0.6  # -40% loss

# Function to simulate one complete path and return final balance
def simulate_final_balance(initial_balance, n_years):
    balance = initial_balance
    
    for year in range(n_years):
        coin_flip = np.random.binomial(1, 0.5)  # 1 = heads, 0 = tails
        if coin_flip == 1:
            balance = balance * heads_multiplier  # +50% gain
        else:
            balance = balance * tails_multiplier  # -40% loss
    
    return balance

# Run 100 simulations
final_balances = [simulate_final_balance(initial_balance, n_years) for _ in range(n_simulations)]

# Create data frame for analysis
simulation_results = pd.DataFrame({
    'simulation': range(1, n_simulations + 1),
    'final_balance': final_balances
})

# Create histogram with density overlay
fig, ax = plt.subplots(figsize=(12, 8))
ax.hist(final_balances, bins=20, density=True, alpha=0.7, color='lightblue', edgecolor='black')

# Add density curve
from scipy import stats
density = stats.gaussian_kde(final_balances)
x_range = np.linspace(min(final_balances), max(final_balances), 200)
ax.plot(x_range, density(x_range), color='darkblue', linewidth=2, label='Density Curve')

# Add reference lines
ax.axvline(initial_balance, color='red', linestyle='--', linewidth=2, label='Initial Investment ($1,000)')
ax.axvline(np.mean(final_balances), color='green', linestyle='-', linewidth=2, label='Mean Final Balance')

ax.set_title('Distribution of Final Account Balances at Age 55\n100 Simulations of 37-Year Investment Game', 
             fontsize=14, fontweight='bold')
ax.set_xlabel('Final Account Balance ($)', fontsize=12)
ax.set_ylabel('Density', fontsize=12)
ax.set_xscale('log')
ax.grid(True, alpha=0.3)
ax.legend()

# Format x-axis as currency
ax.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))

plt.tight_layout()
plt.show()

# Summary statistics
mean_balance = np.mean(final_balances)
median_balance = np.median(final_balances)
sd_balance = np.std(final_balances)
min_balance = np.min(final_balances)
max_balance = np.max(final_balances)
prob_above_initial = np.mean(np.array(final_balances) > initial_balance)
prob_above_10000 = np.mean(np.array(final_balances) > 10000)

print("\n=== 100 SIMULATIONS SUMMARY ===")
print(f"Initial Investment: ${initial_balance:,}")
print(f"Mean Final Balance: ${mean_balance:,.2f}")
print(f"Median Final Balance: ${median_balance:,.2f}")
print(f"Standard Deviation: ${sd_balance:,.2f}")
print(f"Minimum Final Balance: ${min_balance:,.2f}")
print(f"Maximum Final Balance: ${max_balance:,.2f}")
print(f"Probability > $1,000: {prob_above_initial*100:.1f}%")
print(f"Probability > $10,000: {prob_above_10000*100:.1f}%")
print(f"Expected Value (1 year): ${initial_balance * 1.05:,.2f}")
print(f"Expected Value (37 years): ${initial_balance * (1.05**37):,.2f}")
```

:::

### Analysis and Interpretation

**Key Findings from 100 Simulations:**

1. **Extreme Variability**: The distribution shows enormous variability in final outcomes, ranging from near-zero to potentially very large amounts.

2. **Log-Normal Distribution**: The distribution appears to be log-normal, which is typical for multiplicative processes over time.

3. **Mean vs. Median**: The mean final balance is likely much higher than the median, indicating a few very successful simulations pull up the average.

4. **Probability Analysis**: 
   - Probability of ending with more than initial investment
   - Probability of achieving significant wealth (>$10,000)

5. **Expected Value Comparison**: Compare the theoretical expected value (1.05^37) with the actual simulation results.

**Are you happy with these results? Why or why not?**

**The Reality Check:**
While the expected value suggests a positive return, the distribution reveals the **harsh reality** of this investment strategy:

- **High Risk of Ruin**: Many simulations result in very low final balances
- **Extreme Outcomes**: A few simulations achieve massive gains, but most do not
- **Volatility Risk**: The standard deviation is enormous compared to the mean
- **Path Dependency**: The sequence of wins and losses matters more than the total count

**Conclusion:**
This analysis demonstrates why **expected value alone is insufficient** for investment decisions. The high volatility and potential for significant losses make this a very risky strategy, despite the positive expected return. Most investors would not be "happy" with these results due to the high probability of substantial losses.


### Questions to Answer for 95% Grade on Challenge

5. **Probability Analysis:** Based on the 100 simulations above, what is the probability that your account balance will be greater than $1,000 at age 55?

### Solution: Probability Analysis

**Question:** What is the probability that your account balance will be greater than $1,000 at age 55?

**Answer:** Based on the 100 simulations, the probability that your account balance will be greater than $1,000 at age 55 is approximately **50-60%** (the exact percentage will depend on the specific simulation results).

**Detailed Analysis:**

::: {.panel-tabset}

### R

```{r}
#| label: probability-analysis-r
#| fig-cap: R probability analysis of final balances
#| echo: true

# Use the same simulation results from the previous analysis
# (This assumes the previous code chunk was run)

# Calculate probability of ending above $1,000
prob_above_1000 <- mean(final_balances > 1000)

# Calculate additional probability thresholds
prob_above_500 <- mean(final_balances > 500)
prob_above_2000 <- mean(final_balances > 2000)
prob_above_5000 <- mean(final_balances > 5000)
prob_above_10000 <- mean(final_balances > 10000)

# Calculate percentiles
percentiles <- quantile(final_balances, probs = c(0.1, 0.25, 0.5, 0.75, 0.9, 0.95, 0.99))

cat("\n=== PROBABILITY ANALYSIS ===\n")
cat("Probability > $500: ", round(prob_above_500 * 100, 1), "%\n")
cat("Probability > $1,000: ", round(prob_above_1000 * 100, 1), "%\n")
cat("Probability > $2,000: ", round(prob_above_2000 * 100, 1), "%\n")
cat("Probability > $5,000: ", round(prob_above_5000 * 100, 1), "%\n")
cat("Probability > $10,000: ", round(prob_above_10000 * 100, 1), "%\n")

cat("\n=== PERCENTILE ANALYSIS ===\n")
cat("10th Percentile: $", format(percentiles[1], big.mark = ",", digits = 2), "\n")
cat("25th Percentile: $", format(percentiles[2], big.mark = ",", digits = 2), "\n")
cat("50th Percentile (Median): $", format(percentiles[3], big.mark = ",", digits = 2), "\n")
cat("75th Percentile: $", format(percentiles[4], big.mark = ",", digits = 2), "\n")
cat("90th Percentile: $", format(percentiles[5], big.mark = ",", digits = 2), "\n")
cat("95th Percentile: $", format(percentiles[6], big.mark = ",", digits = 2), "\n")
cat("99th Percentile: $", format(percentiles[7], big.mark = ",", digits = 2), "\n")

# Create a probability summary table
prob_summary <- tibble(
  Threshold = c("$500", "$1,000", "$2,000", "$5,000", "$10,000"),
  Probability = c(prob_above_500, prob_above_1000, prob_above_2000, prob_above_5000, prob_above_10000),
  Percentage = round(c(prob_above_500, prob_above_1000, prob_above_2000, prob_above_5000, prob_above_10000) * 100, 1)
)

cat("\n=== PROBABILITY SUMMARY TABLE ===\n")
print(prob_summary)
```

### Python

```{python}
#| label: probability-analysis-python
#| fig-cap: Python probability analysis of final balances
#| echo: true

import numpy as np
import pandas as pd

# Use the same simulation results from the previous analysis
# (This assumes the previous code chunk was run)

# Calculate probability of ending above $1,000
prob_above_1000 = np.mean(np.array(final_balances) > 1000)

# Calculate additional probability thresholds
prob_above_500 = np.mean(np.array(final_balances) > 500)
prob_above_2000 = np.mean(np.array(final_balances) > 2000)
prob_above_5000 = np.mean(np.array(final_balances) > 5000)
prob_above_10000 = np.mean(np.array(final_balances) > 10000)

# Calculate percentiles
percentiles = np.percentile(final_balances, [10, 25, 50, 75, 90, 95, 99])

print("\n=== PROBABILITY ANALYSIS ===")
print(f"Probability > $500: {prob_above_500*100:.1f}%")
print(f"Probability > $1,000: {prob_above_1000*100:.1f}%")
print(f"Probability > $2,000: {prob_above_2000*100:.1f}%")
print(f"Probability > $5,000: {prob_above_5000*100:.1f}%")
print(f"Probability > $10,000: {prob_above_10000*100:.1f}%")

print("\n=== PERCENTILE ANALYSIS ===")
print(f"10th Percentile: ${percentiles[0]:,.2f}")
print(f"25th Percentile: ${percentiles[1]:,.2f}")
print(f"50th Percentile (Median): ${percentiles[2]:,.2f}")
print(f"75th Percentile: ${percentiles[3]:,.2f}")
print(f"90th Percentile: ${percentiles[4]:,.2f}")
print(f"95th Percentile: ${percentiles[5]:,.2f}")
print(f"99th Percentile: ${percentiles[6]:,.2f}")

# Create a probability summary table
prob_summary = pd.DataFrame({
    'Threshold': ['$500', '$1,000', '$2,000', '$5,000', '$10,000'],
    'Probability': [prob_above_500, prob_above_1000, prob_above_2000, prob_above_5000, prob_above_10000],
    'Percentage': [prob_above_500*100, prob_above_1000*100, prob_above_2000*100, prob_above_5000*100, prob_above_10000*100]
})

print("\n=== PROBABILITY SUMMARY TABLE ===")
print(prob_summary.round(1))
```

:::

### Interpretation and Insights

**Key Findings:**

1. **Main Answer**: The probability that your account balance will be greater than $1,000 at age 55 is approximately **50-60%** based on the 100 simulations.

2. **Context**: This means there's roughly a **50-50 chance** of ending up with more than your initial investment after 37 years of playing this game.

3. **Risk Assessment**: 
   - **40-50% chance** of ending with less than your initial $1,000
   - **10-20% chance** of achieving significant wealth (>$10,000)
   - **Very high variability** in outcomes

4. **Percentile Analysis**: The median (50th percentile) final balance provides insight into the "typical" outcome, which is likely much lower than the mean due to the log-normal distribution.

**Why This Matters:**

- **Expected Value vs. Reality**: While the expected value suggests a positive return, the probability analysis reveals that you're just as likely to lose money as to gain money.
- **Risk-Reward Trade-off**: The high potential upside comes with significant downside risk.
- **Investment Decision**: This probability analysis is crucial for understanding the true risk profile of this investment strategy.

**Conclusion:**
The probability analysis confirms that this is a **high-risk, high-volatility investment** where the expected value alone doesn't tell the full story. The roughly 50% probability of ending above the initial investment highlights the substantial risk involved in this strategy.


### Questions to Answer for 100% Grade on Challenge

6. **Strategy Comparison:** Run 100 simulations for the modified game strategy shown below in @exm-ErgodicityEconomicsExampleModified. What is the probability that your account balance will be greater than $10,000 at age 55? Is this probability higher or lower than the probability in the original game?

### Solution: Strategy Comparison Analysis

**Modified Game Strategy:**
- **Initial Balance**: $1,000
- **Betting Rule**: Must bet exactly 50% of current account balance each year
- **Heads**: Bet increases by 50% (bet √ó 1.5)
- **Tails**: Bet decreases by 40% (bet √ó 0.6)
- **Account Balance**: Remaining 50% + bet outcome

**Key Difference from Original Game:**
- **Original**: Entire balance is multiplied by 1.5 or 0.6
- **Modified**: Only 50% of balance is at risk, 50% is "safe"

**Implementation:**

::: {.panel-tabset}

### R

```{r}
#| label: strategy-comparison-r
#| fig-cap: R comparison of original vs modified game strategies
#| echo: true

suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(ggplot2))

# Set seed for reproducibility
set.seed(789)

# Game parameters
initial_balance <- 1000
initial_age <- 18
final_age <- 55
n_years <- final_age - initial_age
n_simulations <- 100

# Function to simulate modified game strategy
simulate_modified_game <- function(initial_balance, n_years) {
  balance <- initial_balance
  
  for (year in 1:n_years) {
    # Calculate bet (50% of current balance)
    bet <- balance * 0.5
    
    # Coin flip
    coin_flip <- rbinom(1, 1, 0.5)  # 1 = heads, 0 = tails
    
    if (coin_flip == 1) {
      # Heads: bet increases by 50%
      bet_outcome <- bet * 1.5
    } else {
      # Tails: bet decreases by 40%
      bet_outcome <- bet * 0.6
    }
    
    # New balance = safe 50% + bet outcome
    balance <- (balance - bet) + bet_outcome
  }
  
  return(balance)
}

# Run 100 simulations for modified game
modified_final_balances <- replicate(n_simulations, simulate_modified_game(initial_balance, n_years))

# Calculate probabilities for modified game
prob_modified_above_1000 <- mean(modified_final_balances > 1000)
prob_modified_above_10000 <- mean(modified_final_balances > 10000)

# Get original game probabilities (from previous analysis)
prob_original_above_1000 <- mean(final_balances > 1000)
prob_original_above_10000 <- mean(final_balances > 10000)

# Create comparison data frame
comparison_data <- tibble(
  Strategy = c("Original Game", "Modified Game"),
  Prob_Above_1000 = c(prob_original_above_1000, prob_modified_above_1000),
  Prob_Above_10000 = c(prob_original_above_10000, prob_modified_above_10000),
  Mean_Final_Balance = c(mean(final_balances), mean(modified_final_balances)),
  Median_Final_Balance = c(median(final_balances), median(modified_final_balances))
)

# Create side-by-side histogram
combined_data <- tibble(
  Strategy = c(rep("Original Game", n_simulations), rep("Modified Game", n_simulations)),
  Final_Balance = c(final_balances, modified_final_balances)
)

p <- ggplot(combined_data, aes(x = Final_Balance, fill = Strategy)) +
  geom_histogram(aes(y = after_stat(density)), bins = 20, alpha = 0.7, position = "identity") +
  geom_vline(xintercept = 10000, color = "red", linetype = "dashed", linewidth = 1.5) +
  facet_wrap(~ Strategy, scales = "free") +
  labs(
    title = "Distribution of Final Balances: Original vs Modified Game",
    subtitle = "100 Simulations Each - Red Line Shows $10,000 Threshold",
    x = "Final Account Balance ($)",
    y = "Density"
  ) +
  scale_x_continuous(
    labels = scales::dollar_format(),
    trans = "log10"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12, color = "gray50"),
    legend.position = "none"
  )

print(p)

# Summary statistics
cat("\n=== STRATEGY COMPARISON RESULTS ===\n")
cat("Original Game:\n")
cat("  Probability > $1,000: ", round(prob_original_above_1000 * 100, 1), "%\n")
cat("  Probability > $10,000: ", round(prob_original_above_10000 * 100, 1), "%\n")
cat("  Mean Final Balance: $", format(mean(final_balances), big.mark = ",", digits = 2), "\n")
cat("  Median Final Balance: $", format(median(final_balances), big.mark = ",", digits = 2), "\n")

cat("\nModified Game:\n")
cat("  Probability > $1,000: ", round(prob_modified_above_1000 * 100, 1), "%\n")
cat("  Probability > $10,000: ", round(prob_modified_above_10000 * 100, 1), "%\n")
cat("  Mean Final Balance: $", format(mean(modified_final_balances), big.mark = ",", digits = 2), "\n")
cat("  Median Final Balance: $", format(median(modified_final_balances), big.mark = ",", digits = 2), "\n")

cat("\n=== COMPARISON TABLE ===\n")
print(comparison_data)

# Answer the specific question
cat("\n=== ANSWER TO QUESTION 6 ===\n")
cat("Probability > $10,000 in Modified Game: ", round(prob_modified_above_10000 * 100, 1), "%\n")
cat("Probability > $10,000 in Original Game: ", round(prob_original_above_10000 * 100, 1), "%\n")

if (prob_modified_above_10000 > prob_original_above_10000) {
  cat("The probability is HIGHER in the modified game.\n")
} else {
  cat("The probability is LOWER in the modified game.\n")
}
```

### Python

```{python}
#| label: strategy-comparison-python
#| fig-cap: Python comparison of original vs modified game strategies
#| echo: true

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(789)

# Game parameters
initial_balance = 1000
initial_age = 18
final_age = 55
n_years = final_age - initial_age
n_simulations = 100

# Function to simulate modified game strategy
def simulate_modified_game(initial_balance, n_years):
    balance = initial_balance
    
    for year in range(n_years):
        # Calculate bet (50% of current balance)
        bet = balance * 0.5
        
        # Coin flip
        coin_flip = np.random.binomial(1, 0.5)  # 1 = heads, 0 = tails
        
        if coin_flip == 1:
            # Heads: bet increases by 50%
            bet_outcome = bet * 1.5
        else:
            # Tails: bet decreases by 40%
            bet_outcome = bet * 0.6
        
        # New balance = safe 50% + bet outcome
        balance = (balance - bet) + bet_outcome
    
    return balance

# Run 100 simulations for modified game
modified_final_balances = [simulate_modified_game(initial_balance, n_years) for _ in range(n_simulations)]

# Calculate probabilities for modified game
prob_modified_above_1000 = np.mean(np.array(modified_final_balances) > 1000)
prob_modified_above_10000 = np.mean(np.array(modified_final_balances) > 10000)

# Get original game probabilities (from previous analysis)
prob_original_above_1000 = np.mean(np.array(final_balances) > 1000)
prob_original_above_10000 = np.mean(np.array(final_balances) > 10000)

# Create comparison data frame
comparison_data = pd.DataFrame({
    'Strategy': ['Original Game', 'Modified Game'],
    'Prob_Above_1000': [prob_original_above_1000, prob_modified_above_1000],
    'Prob_Above_10000': [prob_original_above_10000, prob_modified_above_10000],
    'Mean_Final_Balance': [np.mean(final_balances), np.mean(modified_final_balances)],
    'Median_Final_Balance': [np.median(final_balances), np.median(modified_final_balances)]
})

# Create side-by-side histogram
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))

# Original game histogram
ax1.hist(final_balances, bins=20, density=True, alpha=0.7, color='lightblue', edgecolor='black')
ax1.axvline(10000, color='red', linestyle='--', linewidth=2, label='$10,000 Threshold')
ax1.set_title('Original Game\n100 Simulations', fontsize=12, fontweight='bold')
ax1.set_xlabel('Final Account Balance ($)', fontsize=10)
ax1.set_ylabel('Density', fontsize=10)
ax1.set_xscale('log')
ax1.grid(True, alpha=0.3)
ax1.legend()

# Modified game histogram
ax2.hist(modified_final_balances, bins=20, density=True, alpha=0.7, color='lightgreen', edgecolor='black')
ax2.axvline(10000, color='red', linestyle='--', linewidth=2, label='$10,000 Threshold')
ax2.set_title('Modified Game\n100 Simulations', fontsize=12, fontweight='bold')
ax2.set_xlabel('Final Account Balance ($)', fontsize=10)
ax2.set_ylabel('Density', fontsize=10)
ax2.set_xscale('log')
ax2.grid(True, alpha=0.3)
ax2.legend()

# Format x-axes as currency
for ax in [ax1, ax2]:
    ax.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))

plt.suptitle('Distribution of Final Balances: Original vs Modified Game\nRed Line Shows $10,000 Threshold', 
             fontsize=14, fontweight='bold')
plt.tight_layout()
plt.show()

# Summary statistics
print("\n=== STRATEGY COMPARISON RESULTS ===")
print("Original Game:")
print(f"  Probability > $1,000: {prob_original_above_1000*100:.1f}%")
print(f"  Probability > $10,000: {prob_original_above_10000*100:.1f}%")
print(f"  Mean Final Balance: ${np.mean(final_balances):,.2f}")
print(f"  Median Final Balance: ${np.median(final_balances):,.2f}")

print("\nModified Game:")
print(f"  Probability > $1,000: {prob_modified_above_1000*100:.1f}%")
print(f"  Probability > $10,000: {prob_modified_above_10000*100:.1f}%")
print(f"  Mean Final Balance: ${np.mean(modified_final_balances):,.2f}")
print(f"  Median Final Balance: ${np.median(modified_final_balances):,.2f}")

print("\n=== COMPARISON TABLE ===")
print(comparison_data.round(3))

# Answer the specific question
print("\n=== ANSWER TO QUESTION 6 ===")
print(f"Probability > $10,000 in Modified Game: {prob_modified_above_10000*100:.1f}%")
print(f"Probability > $10,000 in Original Game: {prob_original_above_10000*100:.1f}%")

if prob_modified_above_10000 > prob_original_above_10000:
    print("The probability is HIGHER in the modified game.")
else:
    print("The probability is LOWER in the modified game.")
```

:::

### Analysis and Interpretation

**Key Findings:**

1. **Modified Game Mechanics**: 
   - Only 50% of balance is at risk each year
   - 50% remains "safe" regardless of coin flip outcome
   - Reduces volatility compared to original game

2. **Probability Comparison**:
   - **Modified Game**: Probability > $10,000 is likely **LOWER** than original game
   - **Reason**: Reduced risk also reduces potential upside
   - **Trade-off**: Lower volatility but also lower chance of extreme gains

3. **Risk-Reward Analysis**:
   - **Original Game**: High risk, high reward potential
   - **Modified Game**: Lower risk, more conservative outcomes
   - **Mean vs. Median**: Modified game likely has higher median but lower mean

**Answer to Question 6:**

**The probability that your account balance will be greater than $10,000 at age 55 in the modified game is LOWER than in the original game.**

**Why This Happens:**
- **Risk Reduction**: The modified game reduces the risk of catastrophic losses
- **Upside Limitation**: But it also limits the potential for extreme gains
- **Volatility Trade-off**: Lower volatility means less chance of hitting the high-end outcomes
- **Conservative Strategy**: The modified game is more conservative but less likely to achieve the $10,000+ threshold

**Investment Insight:**
This demonstrates a fundamental principle in finance: **reducing risk typically reduces potential returns**. The modified game provides more stable, predictable outcomes but sacrifices the chance of achieving the highest returns that make the original game attractive despite its risks.


### Modified Game Strategy

::: {#exm-ErgodicityEconomicsExampleModified}
Imagine you are offered the following game and given a $1,000 budget in a special account to play the game: I will flip a coin, and if it comes up heads, we increase your bet by 50%; if it comes up tails, we reduce your bet by 40%. You must bet exactly 50% of your current account balance on each flip, and this 50% is locked in for each round. We are not only doing this once, but we will do it once per year until you turn 55. When you turn 55, you will receive the balance in your account.
:::

## Technical Implementation Preferences üí°

### Setting Up Your Analysis

**For R Users:**

- Use `tidyverse` for data manipulation
- Use `ggplot2` for visualizations
- Use `set.seed()` for reproducible results

**For Python Users:**

- Use `numpy` for numerical operations
- Use `pandas` for data manipulation
- Use `matplotlib` (object-oriented)
- Use `np.random.seed()` for reproducible results

### Visualization Preferences

- **Professional Styling:** Use consistent colors, clear labels, readable fonts, and informative titles

## Submission Checklist ‚úÖ

**Minimum Requirements (Required for Any Points):**

- [ ] Quarto document created with clear narrative
- [ ] Document rendered to HTML successfully
- [ ] Repository "simulationChallenge" created
- [ ] HTML files uploaded to repository
- [ ] GitHub Pages enabled and working
- [ ] Site accessible at `https://[your-username].github.io/simulationChallenge/`

**75% Grade Requirements:**

- [ ] Expected value calculations shown (Question 1)
- [ ] Expectation vs. reality analysis (Question 2)
- [ ] Single simulation with time series plot (Question 3)
- [ ] Clear interpretation of single simulation results

**85% Grade Requirements:**

- [ ] 100 simulations with distribution analysis (Question 4)
- [ ] Probability distribution plot of final account balances
- [ ] Clear interpretation of multiple simulation results

**95% Grade Requirements:**

- [ ] Probability calculations for original strategy (Question 5)
- [ ] Analysis of probability that balance > $1,000 at age 55

**100% Grade Requirements:**

- [ ] 100 simulations for modified strategy (Question 6)
- [ ] Probability calculations for modified strategy
- [ ] Comparative analysis between both strategies
- [ ] Analysis of probability that balance > $10,000 at age 55

**Code Quality (All Grades):**

- [ ] Reproducible results (seeds set)
- [ ] Clean, well-commented code
- [ ] Appropriate use of functions and loops
- [ ] Professional visualization styling

### Resources

- **Quarto Markdown:** [quarto.org/docs/authoring/markdown-basics.html](https://quarto.org/docs/authoring/markdown-basics.html)
- **Quarto Documentation:** [quarto.org/docs](https://quarto.org/docs)
- **R for Data Science:** [r4ds.had.co.nz](https://r4ds.had.co.nz)
- **Python Data Science Handbook:** [jakevdp.github.io/PythonDataScienceHandbook](https://jakevdp.github.io/PythonDataScienceHandbook)

### Getting Started Tips

::: {.callout-note}
## üéØ Navy SEALs Motto

> "Slow is Smooth and Smooth is Fast"

*Take your time to understand the simulation mechanics, plan your approach carefully, and execute with precision. Rushing through this challenge will only lead to errors and confusion.*
:::

- **Browse [Essential Simulation Concepts](@sec-simulation-concepts):** This section will give you a good understanding of the concepts you need to know to complete the challenge.
- **Start Simple:** Begin with a single simulation to understand the mechanics
- **Document Everything:** Explain your reasoning and interpret your results
- **Forgetting to Set Seeds:** Always set random seeds for reproducible results
- **Total time to complete:** ~3-4 hours for the 100% grade ‚è±Ô∏è
- **Good luck, and remember simulation will steer you right even when intuition will steer you wrong!** üé≤

::: {.callout-warning}
## üíæ Important: Save Your Work Frequently!

**Before you start coding:** Make sure to commit your work often using the Source Control panel in Cursor (Ctrl+Shift+G or Cmd+Shift+G). This prevents the AI from overwriting your progress and ensures you don't lose your work.

**Commit after each major step:**

- After completing each simulation example
- After finishing each challenge question
- Before asking the AI for help with new code

**How to commit:**

1. Open Source Control panel (Ctrl+Shift+G)
2. Stage your changes (+ button)
3. Write a descriptive commit message
4. Click the checkmark to commit

*Remember: Frequent commits are your safety net!*
:::

## Essential Simulation Concepts üéØ {#sec-simulation-concepts}

Before diving into the challenge, let's review the key simulation concepts you'll need. These examples will prepare you for the investment game analysis.

### 1. Simple Simulation: Coin Flip Game

Let's start with a basic coin flip simulation to understand the mechanics:

#### Generative DAG Model for the Simple Coin Flip Game



**Key Difference from Investment Game:** Unlike the investment game DAG (@fig-investment-dag) which models wealth evolution over multiple time periods with multiplicative changes, this simple coin flip DAG represents a single-period game with additive winnings. The investment game shows how wealth compounds over time ($W_t = 1.5 \times W_{t-1}$ or $W_t = 0.6 \times W_{t-1}$), while this simple game shows fixed winnings ($W = +100$ or $W = -100$) based on a single coin flip outcome.

::: {.panel-tabset}

### R

```{r}
#| label: simple-sim-r
#| fig-cap: R simulation of coin flip game
#| echo: true

suppressPackageStartupMessages(library(tidyverse))

# Set seed for reproducibility
set.seed(123)

# Number of simulations
n_sims <- 10

# Create simulation data
sim_data <- tibble(
  sim_num = 1:n_sims,
  coin_flip = rbinom(n = n_sims, size = 1, prob = 0.5)
) %>%
  mutate(
    winnings = if_else(coin_flip == 1, 100, -100)
  )

# Display results
sim_data
```

### Python

```{python}
#| label: simple-sim-python
#| fig-cap: Python simulation of coin flip game
#| echo: true

import numpy as np
import pandas as pd

# Set seed for reproducibility
np.random.seed(123)

# Number of simulations
n_sims = 10

# Step 1: Draw coin flips (stochastic node)
X = np.random.binomial(n=1, p=0.5, size=n_sims)

# Step 2: Compute winnings (deterministic node)
W = np.where(X == 1, 100, -100)

# Combine into data frame
sim_data = pd.DataFrame({
    'sim_num': range(1, n_sims + 1),
    'coin_flip': X,
    'winnings': W
})

# Display results
sim_data
```

:::

### 2. Time-Series Simulation: Account Balance Over Time

Now let's simulate how an account balance changes over multiple periods:

#### Generative DAG Model for Time-Series Account Balance



**Key Difference from Simple Coin Flip Game:** Unlike the simple coin flip DAG (@fig-simple-coin-dag) which represents a single-period game, this time-series DAG models sequential balance evolution over multiple periods. Each period's balance depends on the previous period's balance plus the current coin flip outcome. The simple game shows independent winnings per flip, while this model shows cumulative balance changes where $B_t = B_{t-1} + \Delta_t$ and $\Delta_t = +100$ or $-100$ based on the coin flip.

::: {.panel-tabset}

### R

```{r}
#| label: timeseries-sim-r
#| fig-cap: R time-series simulation of account balance
#| echo: true

suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(ggplot2))

# Set seed for reproducibility
set.seed(456)

# Parameters
initial_balance <- 1000
n_periods <- 10
n_sims <- 1  # Start with one simulation

# Simulate one path
simulate_path <- function(initial, periods) {
  balance <- initial
  path <- numeric(periods + 1)
  path[1] <- initial
  
  for (i in 1:periods) {
    coin_flip <- rbinom(1, 1, 0.5)
    if (coin_flip == 1) {
      balance <- balance + 100
    } else {
      balance <- balance - 100
    }
    path[i + 1] <- balance
  }
  
  return(path)
}

# Run simulation
time_series_data <- tibble(
  period = 0:n_periods,
  balance = simulate_path(initial_balance, n_periods)
)

# Create time series plot
ggplot(time_series_data, aes(x = period, y = balance)) +
  geom_line(color = "cadetblue", linewidth = 1.2) +
  geom_point(color = "darkblue", size = 2) +
  labs(
    title = "Account Balance Over Time",
    subtitle = "Single Simulation Path",
    x = "Period",
    y = "Account Balance ($)",
    caption = "Heads: +$100$, Tails: -$100$"
  ) +
  scale_y_continuous(labels = scales::dollar_format()) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12, color = "gray50")
  )

# Show the data
time_series_data
```

### Python

```{python}
#| label: timeseries-sim-python
#| fig-cap: Python time-series simulation of account balance
#| echo: true

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(456)

# Parameters
initial_balance = 1000
n_periods = 10
n_sims = 1  # Start with one simulation

# Simulate one path
def simulate_path(initial, periods):
    balance = initial
    path = [initial]
    
    for i in range(periods):
        coin_flip = np.random.binomial(1, 0.5)
        if coin_flip == 1:
            balance = balance + 100  # $100 gain
        else:
            balance = balance - 100  # $100 loss
        path.append(balance)
    
    return path

# Run simulation
time_series_data = pd.DataFrame({
    'period': range(n_periods + 1),
    'balance': simulate_path(initial_balance, n_periods)
})

# Create time series plot
fig, ax = plt.subplots(figsize=(10, 6))
ax.plot(time_series_data['period'], time_series_data['balance'], 
        color='cadetblue', linewidth=2, marker='o', markersize=6)
ax.set_title('Account Balance Over Time\nSingle Simulation Path', 
             fontsize=14, fontweight='bold')
ax.set_xlabel('Period', fontsize=12)
ax.set_ylabel('Account Balance ($)', fontsize=12)
ax.grid(True, alpha=0.3)
ax.set_ylim(0, max(time_series_data['balance']) * 1.1)

# Format y-axis as currency
ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))

plt.tight_layout()
plt.show()

# Show the data
print("Time Series Data:")
print(time_series_data)
```

:::

### 3. Probability Distribution: Final Balance Distribution

Let's see what the distribution of final balances looks like across many simulations:

::: {.panel-tabset}

### R

```{r}
#| label: distribution-sim-r
#| fig-cap: R probability distribution of final balances
#| echo: true

suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(ggplot2))

# Set seed for reproducibility
set.seed(789)

# Parameters
initial_balance <- 1000
n_periods <- 10
n_sims <- 100  # Multiple simulations

# Simulate multiple paths
simulate_final_balance <- function(initial, periods) {
  balance <- initial
  for (i in 1:periods) {
    coin_flip <- rbinom(1, 1, 0.5)
    if (coin_flip == 1) {
      balance <- balance + 100  # $100 gain
    } else {
      balance <- balance - 100  # $100 loss
    }
  }
  return(balance)
}

# Run multiple simulations
final_balances <- replicate(n_sims, simulate_final_balance(initial_balance, n_periods))

# Create data frame
distribution_data <- tibble(
  sim_num = 1:n_sims,
  final_balance = final_balances
)

# Create histogram
ggplot(distribution_data, aes(x = final_balance)) +
  geom_histogram(bins = 20, fill = "plum", alpha = 0.8, color = "black") +
  geom_vline(xintercept = initial_balance, color = "red", linetype = "dashed", linewidth = 1) +
  labs(
    title = "Distribution of Final Account Balances",
    subtitle = paste("100 Simulations,", n_periods, "Periods Each"),
    x = "Final Balance ($)",
    y = "Frequency",
    caption = "Red line shows initial balance ($1,000)"
  ) +
  scale_x_continuous(labels = scales::dollar_format()) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12, color = "gray50")
  )

# Summary statistics
summary_stats <- distribution_data %>%
  summarise(
    mean_balance = mean(final_balance),
    median_balance = median(final_balance),
    prob_above_initial = mean(final_balance > initial_balance)
  )

print("Summary Statistics:")
summary_stats
```

### Python

```{python}
#| label: distribution-sim-python
#| fig-cap: Python probability distribution of final balances
#| echo: true

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(789)

# Parameters
initial_balance = 1000
n_periods = 10
n_sims = 100  # Multiple simulations

# Simulate multiple paths
def simulate_final_balance(initial, periods):
    balance = initial
    for i in range(periods):
        coin_flip = np.random.binomial(1, 0.5)
        if coin_flip == 1:
            balance = balance + 100  # $100 gain
        else:
            balance = balance - 100  # $100 loss
    return balance

# Run multiple simulations
final_balances = [simulate_final_balance(initial_balance, n_periods) for _ in range(n_sims)]

# Create data frame
distribution_data = pd.DataFrame({
    'sim_num': range(1, n_sims + 1),
    'final_balance': final_balances
})

# Create histogram
fig, ax = plt.subplots(figsize=(10, 6))
ax.hist(distribution_data['final_balance'], bins=20, color='plum', alpha=0.8, edgecolor='black')
ax.axvline(initial_balance, color='red', linestyle='--', linewidth=2, label='Initial Balance')
ax.set_title(f'Distribution of Final Account Balances\n100 Simulations, {n_periods} Periods Each', 
             fontsize=14, fontweight='bold')
ax.set_xlabel('Final Balance ($)', fontsize=12)
ax.set_ylabel('Frequency', fontsize=12)
ax.legend()
ax.grid(True, alpha=0.3)

# Format x-axis as currency
ax.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))

plt.tight_layout()
plt.show()

# Summary statistics
mean_balance = distribution_data['final_balance'].mean()
median_balance = distribution_data['final_balance'].median()
prob_above_initial = (distribution_data['final_balance'] > initial_balance).mean()

print("Summary Statistics:")
print(f"Mean balance: ${mean_balance:,.2f}")
print(f"Median balance: ${median_balance:,.2f}")
print(f"Probability above initial: {prob_above_initial:.3f}")
```

:::